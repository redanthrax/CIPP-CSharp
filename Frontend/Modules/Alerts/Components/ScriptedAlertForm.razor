@using CIPP.Frontend.Modules.Authentication.Interfaces
@using CIPP.Shared.DTOs.Alerts
@using CIPP.Shared.DTOs.Tenants
@using CIPP.Frontend.Modules.Notifications.Interfaces
@using CIPP.Frontend.Modules.Tenants.Interfaces
@using System.ComponentModel.DataAnnotations

@inject ICippApiClient ApiClient
@inject INotificationService NotificationService
@inject ITenantService TenantService

<EditForm Model="@_formModel" OnValidSubmit="@HandleSubmit">
    <DataAnnotationsValidator />

    <MudGrid>
        <!-- Tenant Selection -->
        <MudItem xs="12">
            <MudPaper Class="pa-4" Elevation="2">
                <MudText Typo="Typo.h6" Class="mb-4">Tenant Selector</MudText>
                
                <MudStack Spacing="3">
                    <TenantSelectorOptions @key="@("scripted-main-tenant")"
                                         Value="_selectedTenant"
                                         ValueChanged="@((TenantSelectorOptionDto? value) => { _selectedTenant = value; ValidateForm(); })"
                                         Label="Select Tenant for Alert"
                                         Required="true"
                                         IncludeAllTenants="true"
                                         IncludeGroups="true" />

                    @if (_selectedTenant?.Value == "AllTenants")
                    {
                        <TenantSelectorOptions @key="@("scripted-excluded-tenant")"
                                             Value="_excludedTenant"
                                             ValueChanged="@((TenantSelectorOptionDto? value) => { _excludedTenant = value; OnExcludedTenantSelected(); })"
                                             Label="Excluded Tenants (optional)"
                                             Required="false"
                                             IncludeAllTenants="false"
                                             IncludeGroups="false" />

                        @if (_excludedTenants.Count > 0)
                        {
                            <MudStack Row Spacing="1" Class="flex-wrap">
                                @foreach (var excluded in _excludedTenants)
                                {
                                    <MudChip T="string" OnClose="@(() => RemoveExcludedTenant(excluded))" 
                                           Variant="Variant.Filled" 
                                           Color="Color.Secondary">
                                        @excluded.Label
                                    </MudChip>
                                }
                            </MudStack>
                        }
                    }
                </MudStack>
            </MudPaper>
        </MudItem>

        <!-- Alert Criteria -->
        <MudItem xs="12">
            <MudPaper Class="pa-4" Elevation="2">
                <MudStack Row Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center" Class="mb-4">
                    <MudText Typo="Typo.h6">Alert Criteria</MudText>
                    <MudButton Variant="Variant.Filled" 
                             Color="Color.Primary" 
                             OnClick="@HandleSubmit"
                             StartIcon="@Icons.Material.Filled.Save"
                             Disabled="@(!_isFormValid)">
                        Save Alert
                    </MudButton>
                </MudStack>

                <MudGrid>
                    <!-- Command Selection -->
                    <MudItem xs="12" md="6">
                        <MudAutocomplete T="AlertCommandDto"
                                       Value="_selectedCommand"
                                       ValueChanged="@((AlertCommandDto? value) => { _selectedCommand = value; UpdateRecommendedRecurrence(); ValidateForm(); })"
                                       SearchFunc="@SearchCommands"
                                       Label="What alerting script should run"
                                       ToStringFunc="@(c => c?.Label ?? "")"
                                       Required="true"
                                       Clearable="true">
                            <ItemTemplate Context="command">
                                <MudStack Spacing="1">
                                    <MudText>@command.Label</MudText>
                                    @if (!string.IsNullOrEmpty(command.Description))
                                    {
                                        <MudText Typo="Typo.body2" Color="Color.Secondary">@command.Description</MudText>
                                    }
                                </MudStack>
                            </ItemTemplate>
                        </MudAutocomplete>
                    </MudItem>

                    <!-- Recurrence Selection -->
                    <MudItem xs="12" md="6">
                        <MudSelect Value="_selectedRecurrence"
                                 ValueChanged="@((RecurrenceOptionDto? value) => { _selectedRecurrence = value; ValidateForm(); })"
                                 Label="When should the alert run"
                                 Required="true"
                                 ToStringFunc="@(r => r?.Label ?? "")">
                            @foreach (var recurrence in _recurrenceOptions)
                            {
                                <MudSelectItem Value="@recurrence">@recurrence.Label</MudSelectItem>
                            }
                        </MudSelect>
                    </MudItem>

                    <!-- Start Date/Time -->
                    <MudItem xs="12">
                        <MudDatePicker @bind-Date="_startDate"
                                     Label="When should the first alert run?"
                                     Placeholder="Select date" />
                        <MudTimePicker @bind-Time="_startTime"
                                     Label="Start time"
                                     Placeholder="Select time" />
                    </MudItem>

                    <!-- Command Parameters -->
                    @if (_selectedCommand?.RequiresInput == true)
                    {
                        <MudItem xs="12">
                            @if (_selectedCommand.InputType == "textField")
                            {
                                <MudTextField Value="_commandInput"
                                            ValueChanged="@((string value) => { _commandInput = value; ValidateForm(); })"
                                            Label="@_selectedCommand.InputLabel"
                                            Placeholder="@_selectedCommand.InputPlaceholder"
                                            Required="true" />
                            }
                            else if (_selectedCommand.InputType == "autoComplete")
                            {
                                <MudAutocomplete T="string"
                                               Value="_commandInput"
                                               ValueChanged="@((string? value) => { _commandInput = value ?? string.Empty; ValidateForm(); })"
                                               SearchFunc="@SearchCommandInputOptions"
                                               Label="@_selectedCommand.InputLabel"
                                               Placeholder="@_selectedCommand.InputPlaceholder"
                                               Required="true" />
                            }
                        </MudItem>
                    }

                    <!-- Post-Execution Options -->
                    <MudItem xs="12">
                        <MudSelect T="PostExecutionOptionDto" SelectedValues="_selectedPostExecutions" SelectedValuesChanged="@((IEnumerable<PostExecutionOptionDto> values) => { _selectedPostExecutions = values; ValidateForm(); })" MultiSelection="true" Label="Alert via" Required="true" ToStringFunc="@(p => p?.Label ?? "")">
                            @foreach (var option in _postExecutionOptions)
                            {
                                <MudSelectItem T="PostExecutionOptionDto" Value="@option">@option.Label</MudSelectItem>
                            }
                        </MudSelect>

                        @if (_selectedPostExecutions.Any())
                        {
                            <MudStack Row Spacing="1" Class="flex-wrap mt-2">
                                @foreach (var execution in _selectedPostExecutions)
                                {
                                    <MudChip T="string" Variant="Variant.Filled" Color="Color.Primary">
                                        @execution.Label
                                    </MudChip>
                                }
                            </MudStack>
                        }
                    </MudItem>
                </MudGrid>
            </MudPaper>
        </MudItem>
    </MudGrid>
</EditForm>

@code {
    [Parameter] public AlertConfigurationDto? AlertData { get; set; }
    [Parameter] public bool IsEditMode { get; set; }
    [Parameter] public EventCallback OnSave { get; set; }
    [Parameter] public EventCallback OnCancel { get; set; }

    private CreateScriptedTaskAlertDto _formModel = new();
    private bool _isFormValid = false;
    
    // Form data
    private TenantSelectorOptionDto? _selectedTenant;
    private TenantSelectorOptionDto? _excludedTenant;
    private List<TenantSelectorOptionDto> _excludedTenants = new();
    private AlertCommandDto? _selectedCommand;
    private RecurrenceOptionDto? _selectedRecurrence;
    private IEnumerable<PostExecutionOptionDto> _selectedPostExecutions = new List<PostExecutionOptionDto>();
    private DateTime? _startDate;
    private TimeSpan? _startTime;
    private string _commandInput = string.Empty;
    
    // Available options
    private List<AlertCommandDto> _commandOptions = new();
    private List<RecurrenceOptionDto> _recurrenceOptions = new();
    private List<PostExecutionOptionDto> _postExecutionOptions = new();

    protected override async Task OnInitializedAsync() {
        await LoadOptions();
        
        if (AlertData != null && IsEditMode) {
            await LoadAlertData();
        }
        
        ValidateForm();
    }

    private Task LoadOptions() {

        _commandOptions = new List<AlertCommandDto> {
            new() { 
                Label = "Check for unused licenses",
                Value = "UnusedLicenses",
                Description = "Alerts when there are unused licenses in a tenant",
                RequiresInput = false,
                RecommendedRunInterval = "7d"
            },
            new() { 
                Label = "Check for compromised accounts",
                Value = "CompromisedAccounts",
                Description = "Alerts when potentially compromised accounts are detected",
                RequiresInput = false,
                RecommendedRunInterval = "1h"
            },
            new() { 
                Label = "Custom application check",
                Value = "CustomApp",
                Description = "Check for specific application usage",
                RequiresInput = true,
                InputType = "textField",
                InputLabel = "Application Name",
                InputPlaceholder = "Enter application name",
                InputName = "applicationName"
            }
        };

        _recurrenceOptions = new List<RecurrenceOptionDto> {
            new() { Label = "Every 30 minutes", Value = "30m" },
            new() { Label = "Every hour", Value = "1h" },
            new() { Label = "Every 4 hours", Value = "4h" },
            new() { Label = "Every 1 day", Value = "1d" },
            new() { Label = "Every 7 days", Value = "7d" },
            new() { Label = "Every 30 days", Value = "30d" },
            new() { Label = "Every 365 days", Value = "365d" }
        };

        _postExecutionOptions = new List<PostExecutionOptionDto> {
            new() { Label = "Webhook", Value = "Webhook" },
            new() { Label = "Email", Value = "Email" },
            new() { Label = "PSA", Value = "PSA" }
        };

        // Update recommended recurrence when command changes
        if (_selectedCommand != null) {
            UpdateRecommendedRecurrence();
        }
        return Task.CompletedTask;
    }

    private void UpdateRecommendedRecurrence() {
        if (_selectedCommand?.RecommendedRunInterval != null) {
            // Reset all labels
            foreach (var option in _recurrenceOptions) {
                option.Label = option.Label.Replace(" (Recommended)", "");
            }
            
            // Mark recommended option
            var recommendedOption = _recurrenceOptions.FirstOrDefault(r => r.Value == _selectedCommand.RecommendedRunInterval);
            if (recommendedOption != null) {
                recommendedOption.Label += " (Recommended)";
                if (!IsEditMode) {
                    _selectedRecurrence = recommendedOption;
                }
            }
        }
    }

    private Task LoadAlertData() {
        // TODO: Implement loading existing alert data
        // This would populate the form with existing alert configuration
        return Task.CompletedTask;
    }


    private Task<IEnumerable<AlertCommandDto>> SearchCommands(string value, CancellationToken token) {
        if (string.IsNullOrWhiteSpace(value)) {
            return Task.FromResult<IEnumerable<AlertCommandDto>>(_commandOptions);
        }
        return Task.FromResult<IEnumerable<AlertCommandDto>>(_commandOptions.Where(c => c.Label.Contains(value, StringComparison.OrdinalIgnoreCase)));
    }

    private Task<IEnumerable<PostExecutionOptionDto>> SearchPostExecutionOptions(string value, CancellationToken token) {
        if (string.IsNullOrWhiteSpace(value)) {
            return Task.FromResult<IEnumerable<PostExecutionOptionDto>>(_postExecutionOptions);
        }
        return Task.FromResult<IEnumerable<PostExecutionOptionDto>>(_postExecutionOptions.Where(p => p.Label.Contains(value, StringComparison.OrdinalIgnoreCase)));
    }

    private Task<IEnumerable<string>> SearchCommandInputOptions(string value, CancellationToken token) {
        // This would return available options based on the selected command's input requirements
        var options = new List<string> { "Option 1", "Option 2", "Option 3" };
        if (string.IsNullOrWhiteSpace(value)) {
            return Task.FromResult<IEnumerable<string>>(options);
        }
        return Task.FromResult<IEnumerable<string>>(options.Where(o => o.Contains(value, StringComparison.OrdinalIgnoreCase)));
    }

    private void RemoveExcludedTenant(TenantSelectorOptionDto tenant) {
        _excludedTenants.Remove(tenant);
        ValidateForm();
        StateHasChanged();
    }

    private void OnExcludedTenantSelected() {
        if (_excludedTenant != null && !_excludedTenants.Contains(_excludedTenant)) {
            _excludedTenants.Add(_excludedTenant);
            _excludedTenant = null;
            ValidateForm();
            StateHasChanged();
        }
    }

    private async Task HandleSubmit() {
        try {
            // Create the post object similar to the React implementation
            var startDateTime = _startDate.HasValue && _startTime.HasValue 
                ? new DateTimeOffset(_startDate.Value.Date.Add(_startTime.Value)).ToUnixTimeSeconds()
                : (long?)null;

            var parameters = new Dictionary<string, object>();
            if (_selectedCommand?.RequiresInput == true && !string.IsNullOrEmpty(_commandInput)) {
                parameters[_selectedCommand.InputName ?? "InputValue"] = _commandInput;
            }

            _formModel = new CreateScriptedTaskAlertDto {
                RowKey = IsEditMode && !string.IsNullOrEmpty(AlertData?.RowKey) ? AlertData.RowKey : null,
                TenantFilter = _selectedTenant,
                ExcludedTenants = _excludedTenants,
                Name = $"{_selectedTenant?.Label ?? _selectedTenant?.Value}: {_selectedCommand?.Label}",
                Command = _selectedCommand != null ? $"Get-CIPPAlert{_selectedCommand.Value}" : "",
                Parameters = parameters,
                ScheduledTime = DateTimeOffset.UtcNow.AddMinutes(1).ToUnixTimeSeconds(),
                DesiredStartTime = startDateTime,
                Recurrence = _selectedRecurrence?.Value ?? "",
                PostExecution = string.Join(",", _selectedPostExecutions.Select(p => p.Value))
            };

            var result = await ApiClient.PostAsync<string>("/v1/alerts/scripted", _formModel);
            if (result?.Success == true) {
                await OnSave.InvokeAsync();
            } else {
                NotificationService.ShowError($"Error saving alert: {result?.Message ?? "Unknown error"}");
            }
        } catch (Exception ex) {
            NotificationService.ShowError($"Error saving alert: {ex.Message}");
        }
    }

    private void ValidateForm() {
        _isFormValid = _selectedTenant != null &&
                      _selectedCommand != null &&
                      _selectedRecurrence != null &&
                      _selectedPostExecutions.Any() &&
                      (_selectedCommand.RequiresInput == false || !string.IsNullOrEmpty(_commandInput));
    }

}